https://www.youtube.com/watch?v=cex9XrZCU14&list=PLfqABt5AS4FkW5mOn2Tn9ZZLLDwA3kZUY&index=1

# Fork()

```c
#include <unistd.h>

pid_t fork(void);
```
> - 파라미터 : 없음
> - 반환값 : (부모프로세스/자식프로세스) 
>    - 성공시 : (자식 프로세스의 PID리턴(0보다 큰 값)/0)
>    - 실패시 : (-1/생성되지 않는다.)

현재 실행되는 프로세스에 대한 복사본을 만들어 자식 프로세스를 생성한다. 호출하는 프로세스는 부모 프로세스가 되고 새롭게 생성되는 프로세스는 자식 프로세스가 된다. fork에 의해 생성된 자식 프로세스는 자신만의 PID를 가지게 되며, PPID는 무모프로세스의 PID를 가지게 된다. 성공할 경우 자식 프로세스의 PID가 부모에게 리턴되며, 자식에게는 0이 리턴된다. 실패할 경우에는 -1이 리턴되고, 적절한 error값이 설정된다.

#### pid_t

프로세스 ID를 저장하는 자료형

#### 프로세스

프로세스란 디스크에 있던 프로그램 파일이 메모리에 올려지고 시스템의 스케줄에 따라 실해오디는 실행 단위가 된다. 프로세스는 운영체제로부터 시스템 자원을 할당 받는 단위이고, 스레드는 프로그램 실행 단위이다. 하나의 프로세스가 할당받은 자원을 여러 개의 스레드가 공유하여 사용할 수 있따. 프로세스는 운영체제로부터 메모리, 주소공간 등을 할당 받고 스레드는 할당 받은 자원들을 스레드끼리 공유하며 실행된다.

<<<<<<< HEAD
#### 부모프로세스와 자식 프로세스

- 프로세스 ID가 서로 다르며, 부모 프로세스 ID도 다르다.
- 자식 프로세스의 PPID(getppid(2))는 부모프로세스의 PID(getpid(2)) 같습니다.
- 자식 프로세스에서 리소스 통계는 0으로 초기화됩니다.
- 시그널 설정은 상속되지 않습니다.
- open된 파일은 유지되지만, file lock은 자식 프로세스에서는 해제됩니다.
~~~
양수
    - fork()에서 1 이상을 return 받은 프로세스는 부모 프로세스이며, return값은 자식프로세스ID입니다.
      즉, 부모는 방금 생성한 자식 프로세스 ID를 알 필요가 있기때문에 return 받습니다.
      차일드 프로세스의 종료를 대기하거나 SIGCHLD에 대한 signal 처리를 위해서 필요합니다.
      또한 자식 프로세스ID는 여러개가 있을 수 있기 때문에 자식프로세스ID를 얻는 함수가 없습니다.


0
    - fork()에서 0을 return 받은 프로세스는 차일드 프로세스 자신입니다.
      부모 프로세스 ID는 getppid(2)를 통해서 얻을 수 있기 때문에 0을 return받습니다.


-1
    - 오류가 발생하여 자식 프로세스가 생성되지 않았습니다.  상세 오류내용은 errno에 설정됩니다.

 EAGAIN : 최대 프로세스 갯수 제약(RLIMIT_NPROC)에 도달하여 프로세스 생성에 실패함.
 ENOMEM : 메모리 부족으로 프로세스 생성에 실패함
 ENOSYS : 이 시스템은 메모리관리 unit이 없어서 fork를 지원하지 않음.
 ~~~
=======

# 02 wait

강의에서는 값이 핑퐁으로 된다고 했는데, 나는 값이 핑퐁으로 되는 것이 아니라 부모 먼저 되고 자식이 실행 되었다. 프로세스마다 차이가 있다고 하는 것 같다. 
그리고 코드에서 wait();으로만 표기를 했느데 그러면 에러가 나기 때문에 wait(NULL);로 변경해 줘야 한다.

# 03 Calling fork muliple times
<img width="432" alt="스크린샷 2022-07-07 오후 8 14 03" src="https://user-images.githubusercontent.com/68188768/177760730-7a317ae7-1aa8-4b68-a3b6-db0ab43333de.png">

# use pipe

# FIFO
>>>>>>> c79b8cd8e6427c076b00307861d555ee6b9f7b21
